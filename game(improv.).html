<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Echo Maze — Neon Escape</title>
<style>
:root {
  --bg:#05050a;
  --cyan:#00ffff;
  --yellow:#fff600;
  --green:#00ff90;
}
html, body {
  margin:0; padding:0; height:100%;
  background:var(--bg); overflow:hidden;
  font-family:'Inter',sans-serif; color:#eaf0ff;
  display:flex; justify-content:center; align-items:center;
}
canvas {
  display:block;
  border-radius:16px;
  box-shadow:0 0 50px rgba(0,200,255,0.25),0 0 120px rgba(0,200,255,0.1) inset;
}
#overlay {
  position:absolute; top:50%; left:50%;
  transform:translate(-50%,-50%);
  text-align:center; color:#cfeaff;
  padding:20px 40px; border-radius:20px;
  background:rgba(0,0,20,0.85);
  box-shadow:0 0 40px rgba(0,200,255,0.5);
  backdrop-filter:blur(6px);
  max-width:80%;
  z-index:10;
}
#overlay h1 { font-size:48px; margin:0 0 20px; text-shadow:0 0 25px rgba(0,200,255,0.8);}
#overlay p { font-size:18px; opacity:0.9; margin-bottom:20px; line-height:1.4;}
#overlay button {
  margin-top:12px; padding:12px 22px; border:none; border-radius:12px;
  background:linear-gradient(90deg,var(--cyan),#00ffa6); color:#000;
  font-weight:bold; cursor:pointer; box-shadow:0 0 20px rgba(0,255,200,0.5);
  transition:transform 0.2s, box-shadow 0.2s; font-size:16px;
}
#overlay button:hover {
  transform:scale(1.05); box-shadow:0 0 30px rgba(0,255,200,0.7);
}
#hud {
  position:absolute; top:16px; left:50%;
  transform:translateX(-50%);
  font-size:18px; color:var(--cyan);
  text-shadow:0 0 15px rgba(0,255,200,0.9);
  background:rgba(0,0,20,0.7); padding:6px 12px; border-radius:10px;
  z-index:5;
}
#mobileControls {
  position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
  display:flex; gap:12px; z-index:5;
}
.controlBtn {
  width:60px; height:60px; border-radius:50%;
  background:rgba(0,200,255,0.2); border:2px solid var(--cyan);
  color:#fff; font-weight:bold; font-size:18px; display:flex;
  justify-content:center; align-items:center; cursor:pointer;
  box-shadow:0 0 12px rgba(0,200,255,0.5);
  user-select:none;
}
.controlBtn:active { transform:scale(0.95); box-shadow:0 0 20px rgba(0,255,200,0.7);}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="overlay">
  <h1>Echo Maze</h1>
  <p>Use <b>Arrow Keys / WASD</b> to move.<br>
  Press <b>SPACE</b> or <b>Click</b> to send a sonar pulse.<br>
  Find the glowing exit!</p>
  <p style="font-size:14px;opacity:0.7;">
    This game was created through a conversation with AI: 
    <a href="https://chatgpt.com/share/68d35078-a6fc-8006-9235-592af5452efc" 
       target="_blank" style="color:#00ffa6;">
      View the conversation
    </a>
  </p>
  <button id="startBtn">Start Game</button>
</div>
<div id="hud"></div>
<div id="mobileControls">
  <div class="controlBtn" data-key="ArrowUp">↑</div>
  <div class="controlBtn" data-key="ArrowLeft">←</div>
  <div class="controlBtn" data-key="ArrowDown">↓</div>
  <div class="controlBtn" data-key="ArrowRight">→</div>
  <div class="controlBtn" id="pingBtn">●</div>
</div>

<script>
// --- GAME SETUP ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width = window.innerWidth * 0.9;
let H = canvas.height = window.innerHeight * 0.8;

let running=false, keys={}, player, maze=[], sonar=[], level=1, score=0, particles=[], echoes=5, lives=3;
let exitPulse=0, shield=false, powerUps=[];

// --- UTILITY ---
function randRange(min,max){return Math.random()*(max-min)+min;}
function distance(x1,y1,x2,y2){return Math.hypot(x1-x2,y1-y2);}
function varC(name){return getComputedStyle(document.documentElement).getPropertyValue(name);}

// --- RESET LEVEL ---
function reset(){
  const cols = 16 + (level-1)*3;
  const rows = 12 + (level-1)*2;
  const cellSize = Math.min(W/cols,H/rows);
  const wallChance = Math.min(0.22 + (level-1)*0.05, 0.45);
  
  player={x:cellSize/2,y:cellSize/2,r:12,speed:200};
  maze = generateMaze(cols,rows,cellSize,wallChance);
  sonar=[]; exitPulse=0; particles=[]; powerUps=[];
  echoes=5; lives=3; shield=false;
  
  // spawn random power-ups
  for(let i=0;i<5;i++){
    const type = ['echo','shield','score'][Math.floor(Math.random()*3)];
    powerUps.push({
      x:randRange(40,W-40),
      y:randRange(40,H-40),
      r:10,
      type:type
    });
  }
  updateHUD();
}

// --- GENERATE MAZE ---
function generateMaze(cols,rows,cellSize,wallChance){
  let grid=[];
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(Math.random()<wallChance){
        grid.push({x:c*cellSize,y:r*cellSize,w:cellSize,h:cellSize});
      }
    }
  }
  return grid;
}

// --- SONAR PING ---
function ping(){
  if(echoes>0){
    sonar.push({x:player.x,y:player.y,r:0,max:220});
    echoes--;
  }
}

// --- UPDATE ---
function update(dt){
  // Movement
  let dx=(keys['ArrowRight']||keys['d']?1:0)-(keys['ArrowLeft']||keys['a']?1:0);
  let dy=(keys['ArrowDown']||keys['s']?1:0)-(keys['ArrowUp']||keys['w']?1:0);
  let len=Math.hypot(dx,dy);
  if(len>0){dx/=len;dy/=len;}
  player.x+=dx*player.speed*dt;
  player.y+=dy*player.speed*dt;
  
  // Wall collisions
  for(const wall of maze){
    if(player.x>wall.x&&player.x<wall.x+wall.w&&player.y>wall.y&&player.y<wall.y+wall.h){
      if(!shield){ lives--; if(lives<=0){gameOver(); return;} }
      if(dx>0) player.x=wall.x; if(dx<0) player.x=wall.x+wall.w;
      if(dy>0) player.y=wall.y; if(dy<0) player.y=wall.y+wall.h;
    }
  }
  
  // Sonar update
  for(const s of sonar) s.r+=220*dt;
  sonar = sonar.filter(s=>s.r<s.max);
  
  // Particles
  particles.push({x:player.x+randRange(-4,4),y:player.y+randRange(-4,4),r:randRange(1,3),life:0.6});
  particles = particles.filter(p=>(p.life-=dt)>0);
  
  exitPulse+=dt;
  
  // Power-up pickup
  for(let i=powerUps.length-1;i>=0;i--){
    let pu=powerUps[i];
    if(distance(player.x,player.y,pu.x,pu.y)<player.r+pu.r){
      switch(pu.type){
        case 'echo': echoes+=3; break;
        case 'shield': shield=true; setTimeout(()=>shield=false,5000); break;
        case 'score': score+=50; break;
      }
      powerUps.splice(i,1);
    }
  }
  
  // Check exit
  const ex={x:W-80,y:H-80};
  if(distance(player.x,player.y,ex.x,ex.y)<25){
    levelComplete();
  }
}

// --- DRAW ---
function draw(){
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);
  
  // Sonar
  for(const s of sonar){
    const g=ctx.createRadialGradient(s.x,s.y,0,s.x,s.y,s.r);
    g.addColorStop(0,'rgba(0,200,255,0.35)');
    g.addColorStop(0.5,'rgba(0,200,255,0.08)');
    g.addColorStop(1,'rgba(0,0,0,0)');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
  }
  
  // Maze walls
  ctx.save();
  ctx.fillStyle='rgba(120,180,255,0.25)';
  for(const wall of maze){
    for(const s of sonar){
      const cx=wall.x+wall.w/2, cy=wall.y+wall.h/2;
      if(distance(cx,cy,s.x,s.y)<s.r+80){
        ctx.shadowColor='rgba(0,200,255,0.8)';
        ctx.shadowBlur=12;
        ctx.fillRect(wall.x,wall.y,wall.w,wall.h);
      }
    }
  }
  ctx.restore();
  
  // Power-ups
  for(const pu of powerUps){
    let color = pu.type==='echo'?varC('--cyan'):pu.type==='shield'?varC('--yellow'):varC('--green');
    ctx.fillStyle=color; ctx.beginPath(); ctx.arc(pu.x,pu.y,pu.r,0,Math.PI*2); ctx.fill();
  }
  
  // Exit
  const ex={x:W-80,y:H-80};
  let pulse=30+Math.sin(exitPulse*5)*10;
  const eg=ctx.createRadialGradient(ex.x,ex.y,0,ex.x,ex.y,pulse);
  eg.addColorStop(0,'rgba(0,255,180,0.9)');
  eg.addColorStop(0.5,'rgba(0,200,255,0.25)');
  eg.addColorStop(1,'rgba(0,0,0,0)');
  ctx.fillStyle=eg; ctx.beginPath(); ctx.arc(ex.x,ex.y,pulse,0,Math.PI*2); ctx.fill();
  
  // Player
  ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2);
  ctx.fillStyle=shield?'#ff0':'#fff'; ctx.fill();
  const pg=ctx.createRadialGradient(player.x,player.y,2,player.x,player.y,30);
  pg.addColorStop(0,'#0ff'); pg.addColorStop(1,'transparent');
  ctx.fillStyle=pg; ctx.beginPath(); ctx.arc(player.x,player.y,30,0,Math.PI*2); ctx.fill();
  
  // Particles
  for(const p of particles){
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
    ctx.fillStyle='rgba(0,255,200,'+(p.life*0.7)+')'; ctx.fill();
  }
}

// --- HUD ---
function updateHUD(){
  document.getElementById('hud').innerHTML=`Level: ${level} | Score: ${score} | Echoes: ${echoes} | Lives: ${lives}`;
}

// --- LEVEL COMPLETE ---
function levelComplete(){
  running=false; score+=Math.floor(randRange(50,150));
  document.getElementById('overlay').style.display='block';
  document.getElementById('overlay').innerHTML=`<h1>Level ${level} Complete!</h1>
  <p>Score: ${score}<br>Next Level: ${level+1}<br>
  <button id="nextLevelBtn">Next Level</button></p>`;
  document.getElementById('nextLevelBtn').onclick=()=>{
    level++; reset(); running=true; document.getElementById('overlay').style.display='none';
    last=performance.now(); requestAnimationFrame(loop);
  };
}

// --- GAME OVER ---
function gameOver(){
  running=false;
  document.getElementById('overlay').style.display='block';
  document.getElementById('overlay').innerHTML=`<h1>Game Over</h1>
  <p>Score: ${score}<br><button id="restartBtn">Restart</button></p>`;
  document.getElementById('restartBtn').onclick=()=>{
    level=1; score=0; reset(); running=true;
    document.getElementById('overlay').style.display='none';
    last=performance.now(); requestAnimationFrame(loop);
  };
}

// --- GAME LOOP ---
let last=0;
function loop(ts){if(!running) return; let dt=(ts-last)/1000; last=ts; update(dt); draw(); updateHUD(); requestAnimationFrame(loop);}

// --- INPUT HANDLERS ---
window.addEventListener('keydown', e => { keys[e.key]=true; if(e.key===' '){ping();} });
window.addEventListener('keyup', e => { keys[e.key]=false; });

canvas.addEventListener('click', ()=>{if(running) ping();});

// --- MOBILE BUTTONS ---
document.querySelectorAll('.controlBtn').forEach(btn=>{
  btn.addEventListener('touchstart',e=>{
    const key=btn.dataset.key;
    if(key){keys[key]=true;}
    if(btn.id==='pingBtn'){ping();}
    e.preventDefault();
  });
  btn.addEventListener('touchend',e=>{
    const key=btn.dataset.key;
    if(key) keys[key]=false;
    e.preventDefault();
  });
});

// --- START BUTTON ---
document.getElementById('startBtn').onclick=()=>{
  reset(); running=true; document.getElementById('overlay').style.display='none';
  last=performance.now(); requestAnimationFrame(loop);
};

// --- START SCREEN DRAW ---
reset(); draw();
</script>
</body>
</html>
